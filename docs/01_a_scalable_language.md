# 序章
- "Scala"という名前は"scalable language"からきている
- ユーザの需要の増大にフォーカスして設計されている
- 小さなスクリプトから大きなシステムの構築まで広い範囲に適用できる
- Javaのプラットフォーム上で動き、Javaのライブラリがシームレスに使える
- Scalaはオブジェクト指向と関数プログラミングのコンセプトの両方をブレンドした静的言語である
- Scalaの関数プログラミングは簡単にシンプルなパーツを素早く構築することができる
- Scalaのオブジェクト指向は簡単に大きなシステムの構造を構築したり、新しい要求に適応する構造を持たせることができる

# 1.1 A language that grows on you
- この例(Mapの操作の記述)はPerlやRuby, Pythonといったスクリプト言語のように感じられる
- すべては選んだり必要に応じて適用したライブラリに基づくので、必要に応じてプログラムをあつらえることができる
- Scalaはプログラムによって拡張したり適応したりできる言語である
- Scalaは利便性が高く柔軟性がある言語である

## Growing new types
- すべてが提供された"完璧な言語"である代わりに、あなたの手でそれらを可能にするツールを提供する
- BigIntは'*'や'-'といったオペレータが使えるので組み込みの型のように見えるが、標準ライブラリが提供するクラスである
- ScalaはあたかもScala言語に組み込まれているかのように簡単に使えるライブラリを定義できる
- ユーザは自分の思う方向にScala言語を発展させていくことができる

## Growing new control constructs
- Scalaは型だけでなく、新しい制御構文も進歩させていくことができる
- Scalaにはactorの機能がライブラリとして提供されている
- Erlangのように"!"でメッセージを送信できる。Erlangはこの機能は言語に組み込まれているが、Scalaはライブラリで実現している
- Scalaでは新しいアプリケーションドメインに対応する抽象的な概念を設計/実装することができる
- そしてそれはあたかも組み込みでサポートされるかのように利用できる

# 1.2 What makes Scala scalable?
- Scalaは他の言語よりもオブジェクト指向と関数プログラミングをうまく融合させている
- Scalaではfunction value(関数そのもの？)はオブジェクトであり、関数の型はクラス(サブクラス)である
- このセクションでは、Scalaにおけるオブジェクト指向と関数プログラミングのコンセプトの融合の方法について記載する

## Scala is object-oriented
- Scalaはすべてがオブジェクトなのでpureなオブジェクト指向言語である
- Scalaはすべての操作がメソッド起動である。例えばオペレータ(+)を使ってメソッドを起動することができる
- Scalaはオブジェクトを構成する方法が他の言語よりも進んでいる
- 例えばTrait。TraitはJavaにおけるinterfaceのようであるが、メソッドを実装したりフィールドを持つことができる
- オブジェクトはTraitのメンバが追加され、mixinの構成を取ることができる
- Traitはクラスと違い、superclassが何であれ新しい機能を追加することができる。これがTraitをクラスよりもプラガブルにする
- 特に、多重継承の"ダイヤモンド継承問題"を回避することができる
  - https://dwango.github.io/scala_text/trait.html

## Scala is functional
- Scalaは純粋なオブジェクト指向言語であることに加えて、成熟した関数型言語である
- 関数型言語は2つの特性を持つ
- 1つ目の特性は、関数がファーストクラスの値であること
- ファーストクラスの値である関数は、操作を抽象化して新しい皇族を制御構造を作成する為の便利な手段を提供する
- 関数の汎化は大きな表現力を提供し、時にプログラムの読みやすさや簡潔さにつながる
- 関数の汎化はスケーラビリティに対しても重要な役割を担う
- 例えば、先のactorの例のreceiveの中のコードは、実行されずにreceiveメソッドに渡される関数である
- 関数型言語の2つ目の特性は、プログラム中の操作が、in-placeにデータを変更するのではなく、インプットの値をアウトプットの値に変換するべきことである
- イミューターブルなデータ構造は関数型の礎石である
- ScalaライブラリはJava APIよりも多くのイミュータブルなデータ型を提供している
- 関数型言語の2つめの特性を言い換えると、メソッドは副作用を持つべきではない、ということ
- メソッドは、引数を取り、結果を返すという方法だけでコミュニケーションするべきである
- Scalaは従来のミュータブルなデータや副作用がある命令型のスタイルを使うこともできる
- しかしScalaでは優れた機能的な手段が存在する為、命令型のスタイルを避けようと思えば簡単に避けられるようになっている

# 1.3 Why Scala?
- スケーラビリティ以外にも、Scalaには多くの利点があることが分かった
- このセクションでは特に重要な4つの側面(互換性、簡潔さ、抽象度の高さ、先進的な静的型)について記載する

## Scala is compatible
- ScalaはJavaプラットフォームの中で使うことができるし、Java言語からの逸脱を必要としない
- ScalaはJavaとシームレスな相互運用性を持つように設計されている為、既存のコードに価値を付加することができる
- ScalaのコードはJavaのバイトコードに変換される
- 実行時のパフォーマンスはふつうのJavaプログラムと同様である
- ScalaのコードはJavaのメソッドを読んだり、フィールドにアクセスしたり、Javaクラスを継承にしたり、Javaインターフェースを実装することができる
- 特別な記法や明示的なインターフェース記述、グルーコードを必要としない
- プログラマに認識されていないことが多いが、実際ほとんどのScalaのコードはJavaのライブラリをかなり使っている
- もう一つの相互運用性の側面は、ScalaはJavaの型をかなり使っている
- ScalaのIntはJavaのint、Floatはfloat、Booleanはbooleanで、ScalaのArrayはJavaの配列にマッピングされる
- また、ScalaはJavaの標準ライブラリの型の多くを再利用している
- 再利用だけでなくより良くなるような「ドレスアップ」もしている
- Scalaの文字列は文字列をIntやFloatに変換するtoInt、toFloatといったメソッドをサポートしている
- 型のメンバが合致しなかったり存在しなかった場合に適用されるimplicit conversionを定義することができる
- このケースでは、Stringに対してtoIntメソッドを探し、Scalaコンパイラがそれを見つけれないが、JavaのStringをtoInt等のメソッドを持つScalaのRichStringに変換するimplicit conversionを見つける
- この変換はtoIntが実行される前に暗黙裡に行われる
- ScalaのコードはJavaコードから呼び出すことも可能であるが、これは少し分かりにくい
- JavaよりもScalaの方が言語的な特性が多いので、変換する際にいくつかの機能が必要になる。詳細は29章で説明する

## Scala is concise
- Scalaのプログラムは短くなる傾向になる
- 典型的なScalaプログラムはJavaで書く行の半分ぐらいの行数になる
- コードの行数が少ないことは、タイピングを減らすだけでなく、プログラムを理解しやすくする
- Scalaはコードの行数が少なくなるような特性がいくつかある
- 第一に、Scalaの文法はJavaプログラムで必要になるお決まりの文句を減らすことができる
- 例えば行末に;(セミコロン)を記述する必要がない
- 他にも、Scalaの文法はノイズが少ない点がある
- 例えばJavaとScalaでコンストラクタの書き方を比較する

```java
  // this is Java
  class MyClass {

      private int index;
      private String name;

      public MyClass(int index, String name) {
          this.index = index;
          this.name = name;
      }
  }
```

Scalaでは、代わりに以下のように書く。

```scala
  class MyClass(index: Int, name: String)
Given this code, the Scala compiler will produce a cl
```

要するに、Javaと比較すると冗長さを排除して本来の機能を得ることができる。

Scalaの型インスタンスは簡潔さのもう一つの要素である。繰り返される型情報を排除できることが、プログラムを整然とさせより一層読みやすくする。

- しかし恐らくコードを小さくする最も重要なキーは、ライブラリが揃っている為にコードを書く必要がない点である
- ライブラリの複数の異なる特性はTraitに分割され、柔軟に利用される
- また、ライブラリのメソッド群は、あなたの構文にパラメータ化して組み込むことができる
- これらの構文が、高度で柔軟に利用できるライブラリを定義できるようにする

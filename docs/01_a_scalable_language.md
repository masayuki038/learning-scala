# 序章
- "Scala"という名前は"scalable language"からきている
- ユーザの需要の増大にフォーカスして設計されている
- 小さなスクリプトから大きなシステムの構築まで広い範囲に適用できる
- Javaのプラットフォーム上で動き、Javaのライブラリがシームレスに使える
- Scalaはオブジェクト指向と関数プログラミングのコンセプトの両方をブレンドした静的言語である
- Scalaの関数プログラミングは簡単にシンプルなパーツを素早く構築することができる
- Scalaのオブジェクト指向は簡単に大きなシステムの構造を構築したり、新しい要求に適応する構造を持たせることができる

# 1.1 A language that grows on you
- この例(Mapの操作の記述)はPerlやRuby, Pythonといったスクリプト言語のように感じられる
- すべては選んだり必要に応じて適用したライブラリに基づくので、必要に応じてプログラムをあつらえることができる
- Scalaはプログラムによって拡張したり適応したりできる言語である
- Scalaは利便性が高く柔軟性がある言語である

## Growing new types
- すべてが提供された"完璧な言語"である代わりに、あなたの手でそれらを可能にするツールを提供する
- BigIntは'*'や'-'といったオペレータが使えるので組み込みの型のように見えるが、標準ライブラリが提供するクラスである
- ScalaはあたかもScala言語に組み込まれているかのように簡単に使えるライブラリを定義できる
- ユーザは自分の思う方向にScala言語を発展させていくことができる

## Growing new control constructs
- Scalaは型だけでなく、新しい制御構文も進歩させていくことができる
- Scalaにはactorの機能がライブラリとして提供されている
- Erlangのように"!"でメッセージを送信できる。Erlangはこの機能は言語に組み込まれているが、Scalaはライブラリで実現している
- Scalaでは新しいアプリケーションドメインに対応する抽象的な概念を設計/実装することができる
- そしてそれはあたかも組み込みでサポートされるかのように利用できる

# 1.2 What makes Scala scalable?
- Scalaは他の言語よりもオブジェクト指向と関数プログラミングをうまく融合させている
- Scalaではfunction value(関数そのもの？)はオブジェクトであり、関数の型はクラス(サブクラス)である
- このセクションでは、Scalaにおけるオブジェクト指向と関数プログラミングのコンセプトの融合の方法について記載する

## Scala is object-oriented
- Scalaはすべてがオブジェクトなのでpureなオブジェクト指向言語である
- Scalaはすべての操作がメソッド起動である。例えばオペレータ(+)を使ってメソッドを起動することができる
- Scalaはオブジェクトを構成する方法が他の言語よりも進んでいる
- 例えばTrait。TraitはJavaにおけるinterfaceのようであるが、メソッドを実装したりフィールドを持つことができる
- オブジェクトはTraitのメンバが追加され、mixinの構成を取ることができる
- Traitはクラスと違い、superclassが何であれ新しい機能を追加することができる。これがTraitをクラスよりもプラガブルにする
- 特に、多重継承の"ダイヤモンド継承問題"を回避することができる
  - https://dwango.github.io/scala_text/trait.html

## Scala is functional
- Scalaは純粋なオブジェクト指向言語であることに加えて、成熟した関数型言語である
- 関数型言語は2つの特性を持つ
- 1つ目の特性は、関数がファーストクラスの値であること
- ファーストクラスの値である関数は、操作を抽象化して新しい皇族を制御構造を作成する為の便利な手段を提供する
- 関数の汎化は大きな表現力を提供し、時にプログラムの読みやすさや簡潔さにつながる
- 関数の汎化はスケーラビリティに対しても重要な役割を担う
- 例えば、先のactorの例のreceiveの中のコードは、実行されずにreceiveメソッドに渡される関数である
- 関数型言語の2つ目の特性は、プログラム中の操作が、in-placeにデータを変更するのではなく、インプットの値をアウトプットの値に変換するべきことである
- イミューターブルなデータ構造は関数型の礎石である
- ScalaライブラリはJava APIよりも多くのイミュータブルなデータ型を提供している
- 関数型言語の2つめの特性を言い換えると、メソッドは副作用を持つべきではない、ということ
- メソッドは、引数を取り、結果を返すという方法だけでコミュニケーションするべきである
- Scalaは従来のミュータブルなデータや副作用がある命令型のスタイルを使うこともできる
- しかしScalaでは優れた機能的な手段が存在する為、命令型のスタイルを避けようと思えば簡単に避けられるようになっている

# 1.3 Why Scala?
- スケーラビリティ以外にも、Scalaには多くの利点があることが分かった
- このセクションでは特に重要な4つの側面(互換性、簡潔さ、抽象度の高さ、先進的な静的型)について記載する

## Scala is compatible
- ScalaはJavaプラットフォームの中で使うことができるし、Java言語からの逸脱を必要としない
- ScalaはJavaとシームレスな相互運用性を持つように設計されている為、既存のコードに価値を付加することができる
- ScalaのコードはJavaのバイトコードに変換される
- 実行時のパフォーマンスはふつうのJavaプログラムと同様である
- ScalaのコードはJavaのメソッドを読んだり、フィールドにアクセスしたり、Javaクラスを継承にしたり、Javaインターフェースを実装することができる
- 特別な記法や明示的なインターフェース記述、グルーコードを必要としない
- プログラマに認識されていないことが多いが、実際ほとんどのScalaのコードはJavaのライブラリをかなり使っている
- もう一つの相互運用性の側面は、ScalaはJavaの型をかなり使っている
- ScalaのIntはJavaのint、Floatはfloat、Booleanはbooleanで、ScalaのArrayはJavaの配列にマッピングされる
- また、ScalaはJavaの標準ライブラリの型の多くを再利用している
- 再利用だけでなくより良くなるような「ドレスアップ」もしている
- Scalaの文字列は文字列をIntやFloatに変換するtoInt、toFloatといったメソッドをサポートしている
- 型のメンバが合致しなかったり存在しなかった場合に適用されるimplicit conversionを定義することができる
- このケースでは、Stringに対してtoIntメソッドを探し、Scalaコンパイラがそれを見つけれないが、JavaのStringをtoInt等のメソッドを持つScalaのRichStringに変換するimplicit conversionを見つける
- この変換はtoIntが実行される前に暗黙裡に行われる
- ScalaのコードはJavaコードから呼び出すことも可能であるが、これは少し分かりにくい
- JavaよりもScalaの方が言語的な特性が多いので、変換する際にいくつかの機能が必要になる。詳細は29章で説明する

## Scala is concise
- Scalaのプログラムは短くなる傾向になる
- 典型的なScalaプログラムはJavaで書く行の半分ぐらいの行数になる
- コードの行数が少ないことは、タイピングを減らすだけでなく、プログラムを理解しやすくする
- Scalaはコードの行数が少なくなるような特性がいくつかある
- 第一に、Scalaの文法はJavaプログラムで必要になるお決まりの文句を減らすことができる
- 例えば行末に;(セミコロン)を記述する必要がない
- 他にも、Scalaの文法はノイズが少ない点がある
- 例えばJavaとScalaでコンストラクタの書き方を比較する

```java
  // this is Java
  class MyClass {

      private int index;
      private String name;

      public MyClass(int index, String name) {
          this.index = index;
          this.name = name;
      }
  }
```

Scalaでは、代わりに以下のように書く。

```scala
  class MyClass(index: Int, name: String)
Given this code, the Scala compiler will produce a cl
```

要するに、Javaと比較すると冗長さを排除して本来の機能を得ることができる。

Scalaの型インスタンスは簡潔さのもう一つの要素である。繰り返される型情報を排除できることが、プログラムを整然とさせより一層読みやすくする。

- しかし恐らくコードを小さくする最も重要なキーは、ライブラリが揃っている為にコードを書く必要がない点である
- ライブラリの複数の異なる特性はTraitに分割され、柔軟に利用される
- また、ライブラリのメソッド群は、あなたの構文にパラメータ化して組み込むことができる
- これらの構文が、高度で柔軟に利用できるライブラリを定義できるようにする

## Scala is high-level
- 不幸にも、重要なソフトウェアは複雑な事項を取り扱うことを要求される
- Scalaはインターフェースの抽象度を上げることで複雑さを扱えるようになっている
- 例えば、nameという文字列に大文字が含まれているかどうかを調べるようなケースを想像してみる

```java
  // this is Java
  boolean nameHasUpperCase = false;
  for (int i = 0; i < name.length(); ++i) {
      if (Character.isUpperCase(name.charAt(i))) {
          nameHasUpperCase = true;
          break;
      }
  }
```

- Scalaだと以下のようになる

```scala
val nameHasUpperCase = name.exists(_.isUpperCase)
```

- Javaのコードは文字列をループの中で一文字ずつの要素として扱う
- Scalaのコードは文字列をpredicatesを用いて問い合わせることが可能な高次の文字集合として扱う
- 明らかにScalaのコードはJavaよりも短く理解しやすい
- "_.isUpperCase"というpredicateはScalaの関数リテラルの一例である
- 基本的には、Javaでも抽象的な操作を行うメソッドを持つインターフェースを定義することで、同じようなことを実現できる

```java
  // this is Java
  interface CharacterProperty {
    boolean hasProperty(char ch);
  }
```

```java
  // this is Java
  exists(name, new CharacterProperty() {
      public boolean hasProperty(char ch) {
          return Character.isUpperCase(ch);
      }
  });
```

- これでは多くのコードを書く必要があるが、実際問題としてほとんどのJavaプログラマは気にしない
- 彼らはこれを繰り返していき、コードの複雑さが増していく
- 一方で、Scalaの関数リテラルは軽いので、頻繁に使われる
- Scalaの関数プログラミングスタイルは高次の推論原則も提供する
- そのキーとなる考え方は、関数の適用はその結果によってのみ認識されるという、参照等価である
- 副作用を気にすることなく、関数適用を自由に関数(例えば=)の右辺に置き換えることができる
- この原則は理解やリファクタリングをしやすくする
- 例えば、もう一度先ほどのexistsメソッドを例に取ると、このメソッドは以下の規則を満たすべきである
- 全てのシーケンス's'と、Predicate'p'と'q'のペアは、以下を満たす

```scala
s.exists(p) || s.exists(q) == s.exists(x => p(x) || q(x))
```

- これは、同じシーケンスにそれぞれ'p'と'q'の2つのpredicateを実行し、その結果をorで繋いだものは、シーケンス's'に対して'p'と'q'をテストしてorを取る1つのpredicateの結果と同じになる
- このことが、コードを書いたりリファクタリングする際に明らかに有用である
- しかしながら、existsが副作用を持っている場合、この規則が成り立たない
- 関数プログラミングのスタイルは命令型プログラミングのエイリアス問題も減らす
- エイリアスは複数の変数が同じオブジェクトを参照する際に起きる
- 一方で、イミュータブルなデータはデータをコピーするのでこの問題は起きない
- この利点は特に並列に実行されるコードを書く時に特に決定的である






















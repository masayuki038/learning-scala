# 序章
- "Scala"という名前は"scalable language"からきている
- ユーザの需要の増大にフォーカスして設計されている
- 小さなスクリプトから大きなシステムの構築まで広い範囲に適用できる
- Javaのプラットフォーム上で動き、Javaのライブラリがシームレスに使える
- Scalaはオブジェクト指向と関数プログラミングのコンセプトの両方をブレンドした静的言語である
- Scalaの関数プログラミングは簡単にシンプルなパーツを素早く構築することができる
- Scalaのオブジェクト指向は簡単に大きなシステムの構造を構築したり、新しい要求に適応する構造を持たせることができる

# 1.1 A language that grows on you
- この例(Mapの操作の記述)はPerlやRuby, Pythonといったスクリプト言語のように感じられる
- すべては選んだり必要に応じて適用したライブラリに基づくので、必要に応じてプログラムをあつらえることができる
- Scalaはプログラムによって拡張したり適応したりできる言語である
- Scalaは利便性が高く柔軟性がある言語である

## Growing new types
- すべてが提供された"完璧な言語"である代わりに、あなたの手でそれらを可能にするツールを提供する
- BigIntは'*'や'-'といったオペレータが使えるので組み込みの型のように見えるが、標準ライブラリが提供するクラスである
- ScalaはあたかもScala言語に組み込まれているかのように簡単に使えるライブラリを定義できる
- ユーザは自分の思う方向にScala言語を発展させていくことができる

## Growing new control constructs
- Scalaは型だけでなく、新しい制御構文も進歩させていくことができる
- Scalaにはactorの機能がライブラリとして提供されている
- Erlangのように"!"でメッセージを送信できる。Erlangはこの機能は言語に組み込まれているが、Scalaはライブラリで実現している
- Scalaでは新しいアプリケーションドメインに対応する抽象的な概念を設計/実装することができる
- そしてそれはあたかも組み込みでサポートされるかのように利用できる

# 1.2 What makes Scala scalable?
- Scalaは他の言語よりもオブジェクト指向と関数プログラミングをうまく融合させている
- Scalaではfunction value(関数そのもの？)はオブジェクトであり、関数の型はクラス(サブクラス)である
- このセクションでは、Scalaにおけるオブジェクト指向と関数プログラミングのコンセプトの融合の方法について記載する

## Scala is object-oriented
- Scalaはすべてがオブジェクトなのでpureなオブジェクト指向言語である
- Scalaはすべての操作がメソッド起動である。例えばオペレータ(+)を使ってメソッドを起動することができる
- Scalaはオブジェクトを構成する方法が他の言語よりも進んでいる
- 例えばTrait。TraitはJavaにおけるinterfaceのようであるが、メソッドを実装したりフィールドを持つことができる
- オブジェクトはTraitのメンバが追加され、mixinの構成を取ることができる
- Traitはクラスと違い、superclassが何であれ新しい機能を追加することができる。これがTraitをクラスよりもプラガブルにする
- 特に、多重継承の"ダイヤモンド継承問題"を回避することができる
  - https://dwango.github.io/scala_text/trait.html

## Scala is functional
- Scalaは純粋なオブジェクト指向言語であることに加えて、成熟した関数型言語である
- 関数型言語は2つの特性を持つ
- 1つ目の特性は、関数がファーストクラスの値であること
- ファーストクラスの値である関数は、操作を抽象化して新しい皇族を制御構造を作成する為の便利な手段を提供する
- 関数の汎化は大きな表現力を提供し、時にプログラムの読みやすさや簡潔さにつながる
- 関数の汎化はスケーラビリティに対しても重要な役割を担う
- 例えば、先のactorの例のreceiveの中のコードは、実行されずにreceiveメソッドに渡される関数である
- 関数型言語の2つ目の特性は、プログラム中の操作が、in-placeにデータを変更するのではなく、インプットの値をアウトプットの値に変換するべきことである
- イミューターブルなデータ構造は関数型の礎石である
- ScalaライブラリはJava APIよりも多くのイミュータブルなデータ型を提供している
- 関数型言語の2つめの特性を言い換えると、メソッドは副作用を持つべきではない、ということ
- メソッドは、引数を取り、結果を返すという方法だけでコミュニケーションするべきである
- Scalaは従来のミュータブルなデータや副作用がある命令型のスタイルを使うこともできる
- しかしScalaでは優れた機能的な手段が存在する為、命令型のスタイルを避けようと思えば簡単に避けられるようになっている

# 1.3 Why Scala?
- スケーラビリティ以外にも、Scalaには多くの利点があることが分かった
- このセクションでは特に重要な4つの側面(互換性、簡潔さ、抽象度の高さ、先進的な静的型)について記載する

## Scala is compatible
- ScalaはJavaプラットフォームの中で使うことができるし、Java言語からの逸脱を必要としない
- ScalaはJavaとシームレスな相互運用性を持つように設計されている為、既存のコードに価値を付加することができる
- ScalaのコードはJavaのバイトコードに変換される
- 実行時のパフォーマンスはふつうのJavaプログラムと同様である
- ScalaのコードはJavaのメソッドを読んだり、フィールドにアクセスしたり、Javaクラスを継承にしたり、Javaインターフェースを実装することができる
- 特別な記法や明示的なインターフェース記述、グルーコードを必要としない
- プログラマに認識されていないことが多いが、実際ほとんどのScalaのコードはJavaのライブラリをかなり使っている
- もう一つの相互運用性の側面は、ScalaはJavaの型をかなり使っている
- ScalaのIntはJavaのint、Floatはfloat、Booleanはbooleanで、ScalaのArrayはJavaの配列にマッピングされる
- また、ScalaはJavaの標準ライブラリの型の多くを再利用している
- 再利用だけでなくより良くなるような「ドレスアップ」もしている
- Scalaの文字列は文字列をIntやFloatに変換するtoInt、toFloatといったメソッドをサポートしている
- 型のメンバが合致しなかったり存在しなかった場合に適用されるimplicit conversionを定義することができる
- このケースでは、Stringに対してtoIntメソッドを探し、Scalaコンパイラがそれを見つけれないが、JavaのStringをtoInt等のメソッドを持つScalaのRichStringに変換するimplicit conversionを見つける
- この変換はtoIntが実行される前に暗黙裡に行われる
- ScalaのコードはJavaコードから呼び出すことも可能であるが、これは少し分かりにくい
- JavaよりもScalaの方が言語的な特性が多いので、変換する際にいくつかの機能が必要になる。詳細は29章で説明する

## Scala is concise
- Scalaのプログラムは短くなる傾向になる
- 典型的なScalaプログラムはJavaで書く行の半分ぐらいの行数になる
- コードの行数が少ないことは、タイピングを減らすだけでなく、プログラムを理解しやすくする
- Scalaはコードの行数が少なくなるような特性がいくつかある
- 第一に、Scalaの文法はJavaプログラムで必要になるお決まりの文句を減らすことができる
- 例えば行末に;(セミコロン)を記述する必要がない
- 他にも、Scalaの文法はノイズが少ない点がある
- 例えばJavaとScalaでコンストラクタの書き方を比較する

```java
  // this is Java
  class MyClass {

      private int index;
      private String name;

      public MyClass(int index, String name) {
          this.index = index;
          this.name = name;
      }
  }
```

Scalaでは、代わりに以下のように書く。

```scala
  class MyClass(index: Int, name: String)
Given this code, the Scala compiler will produce a cl
```

要するに、Javaと比較すると冗長さを排除して本来の機能を得ることができる。

Scalaの型インスタンスは簡潔さのもう一つの要素である。繰り返される型情報を排除できることが、プログラムを整然とさせより一層読みやすくする。

- しかし恐らくコードを小さくする最も重要なキーは、ライブラリが揃っている為にコードを書く必要がない点である
- ライブラリの複数の異なる特性はTraitに分割され、柔軟に利用される
- また、ライブラリのメソッド群は、あなたの構文にパラメータ化して組み込むことができる
- これらの構文が、高度で柔軟に利用できるライブラリを定義できるようにする

## Scala is high-level
- 不幸にも、重要なソフトウェアは複雑な事項を取り扱うことを要求される
- Scalaはインターフェースの抽象度を上げることで複雑さを扱えるようになっている
- 例えば、nameという文字列に大文字が含まれているかどうかを調べるようなケースを想像してみる

```java
  // this is Java
  boolean nameHasUpperCase = false;
  for (int i = 0; i < name.length(); ++i) {
      if (Character.isUpperCase(name.charAt(i))) {
          nameHasUpperCase = true;
          break;
      }
  }
```

- Scalaだと以下のようになる

```scala
val nameHasUpperCase = name.exists(_.isUpperCase)
```

- Javaのコードは文字列をループの中で一文字ずつの要素として扱う
- Scalaのコードは文字列をpredicatesを用いて問い合わせることが可能な高次の文字集合として扱う
- 明らかにScalaのコードはJavaよりも短く理解しやすい
- "_.isUpperCase"というpredicateはScalaの関数リテラルの一例である
- 基本的には、Javaでも抽象的な操作を行うメソッドを持つインターフェースを定義することで、同じようなことを実現できる

```java
  // this is Java
  interface CharacterProperty {
    boolean hasProperty(char ch);
  }
```

```java
  // this is Java
  exists(name, new CharacterProperty() {
      public boolean hasProperty(char ch) {
          return Character.isUpperCase(ch);
      }
  });
```

- これでは多くのコードを書く必要があるが、実際問題としてほとんどのJavaプログラマは気にしない
- 彼らはこれを繰り返していき、コードの複雑さが増していく
- 一方で、Scalaの関数リテラルは軽いので、頻繁に使われる
- Scalaの関数プログラミングスタイルは高次の推論原則も提供する
- そのキーとなる考え方は、関数の適用はその結果によってのみ認識されるという、参照等価である
- 副作用を気にすることなく、関数適用を自由に関数(例えば=)の右辺に置き換えることができる
- この原則は理解やリファクタリングをしやすくする
- 例えば、もう一度先ほどのexistsメソッドを例に取ると、このメソッドは以下の規則を満たすべきである
- 全てのシーケンス's'と、Predicate'p'と'q'のペアは、以下を満たす

```scala
s.exists(p) || s.exists(q) == s.exists(x => p(x) || q(x))
```

- これは、同じシーケンスにそれぞれ'p'と'q'の2つのpredicateを実行し、その結果をorで繋いだものは、シーケンス's'に対して'p'と'q'をテストしてorを取る1つのpredicateの結果と同じになる
- このことが、コードを書いたりリファクタリングする際に明らかに有用である
- しかしながら、existsが副作用を持っている場合、この規則が成り立たない
- 関数プログラミングのスタイルは命令型プログラミングのエイリアス問題も減らす
- エイリアスは複数の変数が同じオブジェクトを参照する際に起きる
- 一方で、イミュータブルなデータはデータをコピーするのでこの問題は起きない
- この利点は特に並列に実行されるコードを書く時に特に決定的である

## Scala is statically typed
- 我々はScalaの型システムが"complete pain"ではないということをこの本で説明したい
- 実際、それは静的型付けについて2つの素晴らしい関心事に作用する
- 型インターフェースによって冗長さは排除され、パターンマッチや型の記述、構成の新しい方法を通して柔軟性が得られる
- これらの障害を排除して、静的型システムの古典的な利点をより理解することができる
- これらの恩恵の重要なものは、抽象特性の検証性、安全なリファクタリング、より良いドキュメンテーションである

### Verifiable properties.
- 静的型付きシステムは特定の実行エラーがないことを証明する
- 例えば、booleansがintegersに追加できないこと、private変数がクラスの外からアクセスできないこと、関数が正しい引数の数で呼び出されること、文字列群には文字列のみ追加できること、といった特性を証明できる
- 他の種類のエラーは今日の静的型付きシステムでは検知できない
- 例えば、関数が終わっていないこと、配列の境界違反、0除算は検知できない
- また、プログラムが仕様に則っているかも検知できない(仕様があればの話だが)
- それ故、静的型付きは有用ではないと却下されることもある
- そのような型システムはシンプルなエラーを検知できるだけで、ユニットテストはより広範囲なカバーを提供するのに、静的型付きの議論をするのはなぜか？
- これらの議論がポイントを外していると考えているからだ
- 静的型付きシステムは確かにユニットテストの代わりにはなれないが、ユニットテストの数を減らすことができる
- 同じようにユニットテストも静的型付きの代わりにはなれない
- Edsger Dijkstraは、"テストはエラーがあることを明らかにするだけで、エラーが無いことを証明するわけではない"
- 故に静的型付が提供する保証はシンプルだが、テストの量では提供できない本当の形式保証である

### Safe refactorings.
- 静的型付きシステムは自信を持ってコードベースを変更することができるセーフティネットを提供する
- 例えばあるメソッドに一つ引数を追加するリファクタリングを考えてみる
- 静的型付き言語では、変更し、リコンパイルして、型エラーになった箇所をすべて修正することができる
- 修正が完了すると、変更するべき点はすべて見つけたと確信できる
- メソッド名を変えたり、メソッドを別のクラスに移動するようなシンプルなリファクタリングでも同様である
- そららのケースにおいて静的型付きチェックは新しいシステムが以前と同様に動作することを保証する

### Documentation.
- 静的型付きはコンパイラによって正しさをチェックされたプログラムドキュメントである
- 通常のコメントとは異なり、型の記述は古くなることはない
- さらに、コンパイラやIDEはコンテキストを補助するより良い型記述を利用することができる
- 例えば、IDEは選択された式の静的型を判別し、その型のすべてのメンバーを検索することによって、選択可能なすべてのメンバーを表示できる
- 静的型付きは通常有用なプログラムドキュメントだが、時々プログラムを見づらくしてしまう
- 典型的に、有用なドキュメントはプログラムの読み手が彼ら自身によって簡単に導き出すことができないものである
- Scalaはとても洗練された型インターフェースを持っている為、大部分の型情報を省略することができる
- Scalaの型インターフェースはとても先進的なものである
- 実際、ユーザが型を明記することはほとんどない
- それゆえ、Scalaのプログラムはちょっと動的言語っぽい
- 特にクライアントアプリケーションにおけるライブラリコンポーネント間の結合のコードで見受けられる
- 最終的に、再利用可能なコンポーネントを作り上げる為にも、メンバの型のシグネチャは明記されるべきである、なぜなら、それらはコンポーネントとクライアントの間の契約の本質的な部分を構成するからである

# 1.4 Scala's roots
- Scalaは沢山の他の言語から影響を受けている
- Scala特有の機能は少ない
- Scalaもプログラミング言語のフィールドに貢献する。例えば、その抽象型はオブジェクト指向を、Traitはより柔軟なコンポーネントの組み合わせを、その抽出器はより自由なパターンマッチを提供する
- これらの技術革新は近年のプログラミング言語のカンファレンスで論文が発表されている

# テスト


































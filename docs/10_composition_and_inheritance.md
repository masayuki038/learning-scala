# 序章

- 6章ではScalaのオブジェクト指向の側面を紹介した
- この章では、6章では省略したものをピックアップし、Scalaのオブジェクト指向プログラミングをサポートするより優れた事項に踏み込んでいく
- クラス間の基本的な関係、集約と継承を比較する
- 集約は一つのクラスがもう一方の参照を保持しており、その参照されたクラスはそのミッションを満たすのをサポートする
- 継承は親クラス、子クラスの関係である
- これらのトピックに加えて、抽象クラス、パラメータ無しのメソッド、クラスの拡張、メソッドやフィールドのオーバーラード、パラメータ化されたフィールド、親クラスのコンストラクタの起動、ポリモーフィズム、動的なバインディング、finalのメンバやクラス、ファクトリーオブジェクトやメソッドについて議論する

# 10.1 A two-dimensional layout library

- この章の動くプログラム例として、2つの次元のレイアウト要素を構築してレンダリングするライブラリを作成する
- それぞれの要素はテキストで埋められた矩形を表現する
- 利便性から、そのライブラリは指定されたデータから新しい要素を作成する`elem`というファクトリーメソッドを提供する
- 例えば、次のようなシグネチャでファクトリーメソッドを使って、文字列を含む要素を作成することができる

```scala
 elem(s: String): Element
```

- 要素はElementという名前の型でモデル化されている
- 2つの要素を組み合わせて新しい要素を作る為に、ひとつの要素に2つめの要素を渡し、`above`や`beside`を呼び出すことができる
- 例えば次の式は、それぞれの高さが2である、2つの列で構成される大きな要素を構築する

```scala
  val column1 = elem("hello") above elem("***")
  val column2 = elem("***") above elem("world")
  column1 beside column2
```

- この式の結果を出力は以下のようになる

```
hello ***
*** world
```

- レイアウト要素は、操作を組み合わせる目的を持ったシンプルなパーツからオブジェクトを構築するシステムの良い例である
- この章では、シンプルなパーツである配列、行、矩形から構築される要素のオブジェクトのクラスを定義する
- また、`above`や`beside`という構築操作を定義する
- そのような構築操作は、いくつかのドメインの要素を組み合わせて1つの新しい要素にするので、通常コンビネータとも呼ばれる
- コンビネータについて考えることは、ライブラリを設計する上で一般的に良い方法である
- アプリケーションドメインのオブジェクトを構築するための基本的な方法について考える
- シンプルなオブジェクトとは何か？
- よりシンプルなオブジェクトから機能的なオブジェクトを構築する方法とは？
- どのようにコンビネータを組み合わせるか？
- もっとも一般的なコンビネータは何か？
- どうルールを満たすか？
- これらの問いに答えられるのであれば、ライブラリの設計は順調に進んでいる

# 10.2 Abstract classes

- 最初のタスクはレイアウト要素を表現する`Element`型を定義することである
- 要素は文字列で構成される2つの次元の矩形なので、レイアウト要素を参照する`contents`というメンバを持つ
- `contents`は、おのおのの文字列が1行になっている`Array[String]`で表現される
- それゆえ、`contents`によって返された結果の方もまた`Array[String]`である

```scala
    abstract class Element {
      def contents: Array[String]
    }
```

- このクラスでは、`contents`は実装を持たないメソッドとして宣言される
- 言い換えると、そのメソッドは`Element`クラスの抽象メンバである
- 抽象メンバを持つクラスは`class`キーワードの前に`abstract`と書くことで抽象クラスとして宣言する必要がある

```scala
  abstract class Element ...
```

- `abstract`修飾子は、実装されていない抽象メンバがあることを示す
- 結果として、抽象クラスをインスタンス化することはできない
- インスタンス化しようとすると、以下のようにコンパイルエラーがでる

```scala
  scala> new Element
  <console>:5: error: class Element is abstract;
      cannot be instantiated
         new Element
             ^
```

- この章の後で、未定義の部分を実装してインスタンス化できるように`Element`クラスのサブクラスの作り方を紹介する
- Note: `Element`クラスの実装されたメンバには`abstract`修飾子を付けない
- 実装が無いメソッドが`abstract`である
- Javaと異なり、メソッド宣言に`abstract`修飾子は必要無い
- 実装されているメソッドは`concrete`と呼ばれる
- 「宣言」と「定義」は少し異なる
- `Element`クラスは`abstract`メソッドを宣言しているが、`concrete`メソッドは定義していない
- しかしながら、次のセクションでいくつかの`concrete`メソッドを定義することで`Element`を拡張する

# 単語
- fulfill: 実現させる、満たす、果たす
- on track: 軌道に乗って、順調に進んで、再テストされて
- make sence: 意味をなす、道理にかなう、うなずける
- signify: ～を意味する、～を表す、示す
# 序章

- 6章ではScalaのオブジェクト指向の側面を紹介した
- この章では、6章では省略したものをピックアップし、Scalaのオブジェクト指向プログラミングをサポートするより優れた事項に踏み込んでいく
- クラス間の基本的な関係、集約と継承を比較する
- 集約は一つのクラスがもう一方の参照を保持しており、その参照されたクラスはそのミッションを満たすのをサポートする
- 継承は親クラス、子クラスの関係である
- これらのトピックに加えて、抽象クラス、パラメータ無しのメソッド、クラスの拡張、メソッドやフィールドのオーバーラード、パラメータ化されたフィールド、親クラスのコンストラクタの起動、ポリモーフィズム、動的なバインディング、finalのメンバやクラス、ファクトリーオブジェクトやメソッドについて議論する

# 10.1 A two-dimensional layout library

- この章の動くプログラム例として、2つの次元のレイアウト要素を構築してレンダリングするライブラリを作成する
- それぞれの要素はテキストで埋められた矩形を表現する
- 利便性から、そのライブラリは指定されたデータから新しい要素を作成する`elem`というファクトリーメソッドを提供する
- 例えば、次のようなシグネチャでファクトリーメソッドを使って、文字列を含む要素を作成することができる

```scala
 elem(s: String): Element
```

- 要素はElementという名前の型でモデル化されている
- 2つの要素を組み合わせて新しい要素を作る為に、ひとつの要素に2つめの要素を渡し、`above`や`beside`を呼び出すことができる
- 例えば次の式は、それぞれの高さが2である、2つの列で構成される大きな要素を構築する

```scala
  val column1 = elem("hello") above elem("***")
  val column2 = elem("***") above elem("world")
  column1 beside column2
```

- この式の結果を出力は以下のようになる

```
hello ***
*** world
```

- レイアウト要素は、操作を組み合わせる目的を持ったシンプルなパーツからオブジェクトを構築するシステムの良い例である
- この章では、シンプルなパーツである配列、行、矩形から構築される要素のオブジェクトのクラスを定義する
- また、`above`や`beside`という構築操作を定義する
- そのような構築操作は、いくつかのドメインの要素を組み合わせて1つの新しい要素にするので、通常コンビネータとも呼ばれる
- コンビネータについて考えることは、ライブラリを設計する上で一般的に良い方法である
- アプリケーションドメインのオブジェクトを構築するための基本的な方法について考える
- シンプルなオブジェクトとは何か？
- よりシンプルなオブジェクトから機能的なオブジェクトを構築する方法とは？
- どのようにコンビネータを組み合わせるか？
- もっとも一般的なコンビネータは何か？
- どうルールを満たすか？
- これらの問いに答えられるのであれば、ライブラリの設計は順調に進んでいる

# 10.2 Abstract classes

- 最初のタスクはレイアウト要素を表現する`Element`型を定義することである
- 要素は文字列で構成される2つの次元の矩形なので、レイアウト要素を参照する`contents`というメンバを持つ
- `contents`は、おのおのの文字列が1行になっている`Array[String]`で表現される
- それゆえ、`contents`によって返された結果の方もまた`Array[String]`である

```scala
    abstract class Element {
      def contents: Array[String]
    }
```

- このクラスでは、`contents`は実装を持たないメソッドとして宣言される
- 言い換えると、そのメソッドは`Element`クラスの抽象メンバである
- 抽象メンバを持つクラスは`class`キーワードの前に`abstract`と書くことで抽象クラスとして宣言する必要がある

```scala
  abstract class Element ...
```

- `abstract`修飾子は、実装されていない抽象メンバがあることを示す
- 結果として、抽象クラスをインスタンス化することはできない
- インスタンス化しようとすると、以下のようにコンパイルエラーがでる

```scala
  scala> new Element
  <console>:5: error: class Element is abstract;
      cannot be instantiated
         new Element
             ^
```

- この章の後で、未定義の部分を実装してインスタンス化できるように`Element`クラスのサブクラスの作り方を紹介する
- Note: `Element`クラスの実装されたメンバには`abstract`修飾子を付けない
- 実装が無いメソッドが`abstract`である
- Javaと異なり、メソッド宣言に`abstract`修飾子は必要無い
- 実装されているメソッドは`concrete`と呼ばれる
- 「宣言」と「定義」は少し異なる
- `Element`クラスは`abstract`メソッドを宣言しているが、`concrete`メソッドは定義していない
- しかしながら、次のセクションでいくつかの`concrete`メソッドを定義することで`Element`を拡張する

# 10.3 Defining parameterless methods

- 次のステップとして、幅と高さを公開するメソッドを`Element`に追加する
- `height`メソッドは行数を返す
- `width`メソッドは最初の行の長さを返すか、行が無い場合は0を返す

```scala
  abstract class Element {
    def contents: Array[String]
    def height: Int = contents.length
    def width: Int = if (height == 0) 0 else contents(0).length
  }
```

- `Element`の3つのメソッドは、空の引数リストも含めて、引数リストを持たない

```scala
 def width(): Int
```

- 上記のような記述の代わりに以下のように書く

```scala
def width: Int
```

- Scalaでは、パラメータ無しのメソッドは良く使われる
- 反対に、メソッドは`def height(): Int`のように空のパラメータリスト`()`を用いて定義される
- 推奨される慣習としては、引数が無く、オブジェクトのフィールドの値を返すだけの(特にオブジェクトの状態を変更しない)メソッドの時にパラメータ無しのメソッドを使う
- この慣習は、クライアントコードが属性やメソッドの実装内容に影響されるべきではない、という`uniform access principal`をサポートする
- この例は、`width`と`height`を単にdefをvalに変更することで、メソッドの代わりにフィールドとすることを選択する

```scala
  abstract class Element {
    def contents: Array[String]
    val height = contents.length
    val width =
      if (height == 0) 0 else contents(0).length
  }
```

- 2つの定義のそれぞれは、クライアントの視点で見ると全く等価である
- 唯一の違いは、メソッドの起動よりもフィールドを参照する方が少し速い点である
- なぜなら、フィールドの値はクラスが初期化された時に事前に計算されており、メソッドは呼び出された時に計算するからである
- もう一方で、フィールドはそれぞれの`Element`オブジェクトで別途メモリが必要である
- それゆえ、属性をフィールドかメソッドのどちらで表現するかは使われ方に依るし、使われ方は時間と共に変わるだろう
- ポイントは内部の実装が変わっても`Element`クラスのクライアントは影響を受けないようにするべきである
- 特に、`Element`クラスのクライアントは、アクセス関数が副作用がなく状態を変更しない限り、フィールドをアクセス関数に書き換える場合、書き換える必要がないようにするべきである
- クライアントはどちらの方式かを気にする必要がない

# 単語
- fulfill: 実現させる、満たす、果たす
- on track: 軌道に乗って、順調に進んで、再テストされて
- make sence: 意味をなす、道理にかなう、うなずける
- signify: ～を意味する、～を表す、示す
- reveal: 見せる、公開する、明らかにする

# 序章

- Scalaは一握りの制御構造しか持たない
- 制御構造は`if`、`while`、`for`、`try`、`match`と関数呼び出しだけである
- Scalaの制御構造が少ない理由の発端は、関数リテラルを持っているからである
- 相次ぐ基本的な文法でより高いレベルの制御構造を積み上げる代わりに、Scalaはライブラリでそれらを積み上げる
- 9章ではそれがどのように実行されるか詳細に示す
- この章では、これらの少ないビルトインされている制御構造を示す
- Scalaの制御構造は何かしらの値を返すことに気が付くだろう
- これは関数型言語のアプローチで、プログラムは値を計算するものと見なされ、それ故コンポーネントもまた値を計算するべきである
- この論理制御構造のアプローチは最近の命令プログラミング言語にも採用されている
- 命令プログラミング言語は、関数呼び出しは引数で与えられた値で出力内容を更新するが、関数呼び出しは値を返すこともできる
- 加えて、命令プログラミングはしばしば、`if`と同じ振る舞いをする(但し値を返す)三項演算子を持つ
- Scalaはこの三項演算子モデルを採用したが、これを`if`としている
- 言い換えると、Scalaの`if`は値を返す
- Scalaはこの方針に則り、`for`、`try`、`match`もまた値を返す
- プログラマは関数の戻り値を使うのと同じように、これらの結果値を使用してコードを単純化することができる
- この仕組みが無いと、プログラマは制御構造で計算された値を保持する為に一時変数を作成する必要がある
- 一時変数の利用を除去することは、コードをシンプルにし、値を設定し忘れるようなバグを防ぐ
- 全体として、Scalaの基本構造は、ミニマルであるが、命令プログラミング言語の本質的な部分をすべて備えている
- さらに、結果値を一貫して取得することで、コードを短くすることができる
- どのように動作するかを説明するために、この章ではScalaの基本的な制御構造を詳しく見ていく

# 7.1 If expressions

- Scalaの`if`は他の言語と同様、条件をテストして、その結果がtrueかどうかで2つのブランチのひとつを実行する
- これは命令プログラミングスタイルの一般的な例である

```scala
var filename = "default.txt"
if (!args.isEmpty)
  filename = args(0)
```

- このコードは`filename`という変数を宣言し、デフォルトの値を初期化する
- その後、引数が1つでもあるかをチェックする為に`if`式を使う
- もしそうであれば、変数に設定されている値を変更する
- Scalaの`if`は結果を返すので、このコードはもっとうまく書くことができる
- 以下のコードはvarを使わず前の例と同じ結果になる

```scala
val filename =
  if (!args.isEmpty) args(0)
  else "default.txt"
```

- この時、`if`は2つの分岐を持つ
- `args`が空でない時、初期値は`args(0)`になる
- そうでなければ、デフォルトの値になる
- `if`式に結果が返ると、`filename`変数はその値で初期化される
- このコードはちょっと短くなったが、実際の利点はvarの代わりにvalを使っていることだ
- valを使うのは関数型のスタイルっで、Javaのfinalの変数と同じように役に立つ
- コードの読み手に、変数の値が決して変わることがなく、値の変更箇所を調べる為にすべてのコードを見る必要がない
- 2つ目の利点は、varの代わりにvalを使うと、等式推論がサポートされ、より良くなる
- 導入された変数は、式に副作用がないと仮定して、それを計算する式に等しい
- これは、変数名を書く時はいつでも、式を書く代わりとできる
- 例として、`println(filename)`の代わりに、以下のように書くことができる`

```scala
println(if (!args.isEmpty) args(0) else "default.txt")
```

- この選択はあなたのものだ
- もう一方の方法で書くことができる
- valを使うことは、時間とともにコードが改善されていくように安全にリファクタリングできるようにする

# 7.2 While loops

- Scalaの`while`は他の言語と同様に、条件とボディがあり、条件結果が`true`の間はボディを何度も実行する

```scala
    def gcdLoop(x: Long, y: Long): Long = {
      var a = x
      var b = y
      while (a != 0) {
        val temp = a
        a = b % a
        b = temp
      }
      b
    }
```

- Scalaは`do-while`もある。これはボディを実行した前ではなく後に条件をテストする

```scala
    var line = ""
    do {
      line = readLine()
      println("Read: "+ line)
    } while (line != "")
```

- `while`と`do-while`は"loops"と呼ばれる構文で、式ではない、なぜなら、それらは値を返さない
- 結果の型は`Unit`となる
- `Unit`という型を持つ値が存在していることがわかる
- それは`unit value`と呼ばれ、`()`と記述される
- `()`の存在は、Javaの`void`とは異なる

```scala
  scala> def greet() { println("hi") }
  greet: ()Unit

  scala> greet() == ()
  hi
  res0: Boolean = true
```

- ボディの前に`=`が無いので、`greet`は`Unit`の結果を産み出す
- それゆえ、`greet`は`()`というunitの値を返す
- それは次の行で、`greet`の結果と`()`を比較して`true`が返ってきていることで確かめることができる






# 単語

- handful: 一握り、少量、少数
- inception: 初め、発端
- after another: 相次ぎ
- accumulate: 蓄積する、積もる、堆積する
- sufficient: 十分な、足りる
- turn out: 結果的に～であることがわかる、～という状態で終わる、～になる
- construct: 構文


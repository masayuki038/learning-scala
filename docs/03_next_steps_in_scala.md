# 序章
- この章は前章に続きScalaの基礎編である
- この章ではもう少し先進的な機能を紹介する
- この章を終了した時、Scalaで有用なスクリプトを書き始めることができる知識を十分に得られる
- Scalaを感じる最も良い方法は、Scalaのコードを書き始めることだ

# Step 7. Parameterize arrays with types
- Scalaでは、newを使ってオブジェクトを生成することができる
- オブジェクトを生成する際、型とパラメータを指定する
- パラメータは生成するインスタンスの設定を意味する
- コンストラクタのカッコ内にオブジェクトを渡すことによって、インスタンスのパラメータを設定する
- 例えば、以下のScalaコードは12345を指定してBigIntegerのインスタンスを生成する

```
val big = new java.math.BigInteger("12345")
```

- インスタンスを生成する際、ブラケット括弧に1つ以上の型を指定する
- 例えば以下の例では、greetStringは先頭行でパラメータ'3'を指定して、配列の長さ3で要素の型がStringの配列を生成する
- 型と値をパラメータに取る時、ブラケット括弧内に型が最初に来て、その後にカッコ内に値を指定する

```
val greetStrings = new Array[String](3)

greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"
```

- 前記のとおり、Scalaの配列は、Javaのブラケット括弧内にインデックスを指定するのではんかう、丸括弧内に指定してアクセスする
- 配列のインデックス0は、greetStrings[0]ではなくgreetStrings(0)でアクセスする
- この3行のコードは、Scalaのvalの意義を理解するのに重要なコンセプトを示す
- valの変数に一旦値を割り当てると、再び割り当てることはできない
- しかし、それが参照する先の値は変更することができる
- このケースでは、greetStringsに別の配列を割り当てることができない
- しかしArray[String]の要素は変更することができる。つまり、配列そのものはmutableである
- 最後の2行は、greetStringsの配列の各要素を次々と出力する

```
for (i <- 0 to 2)
  print(greetStrings(i))
```

- Scalaのもう一つの一般的なルールを示す
- メソッドが一つの引数しか取らない場合、dotあるいは括弧を付けることなく、そのメソッドを呼び出すことができる
- この例では、実際にtoメソッドは一つのInt引数を取る
- `0 to 2`というコードは`(0).to(2)`というメソッドに変換される
- この記法はメソッド呼び出しのレシーバーを明示的に指定した時のみ有効である
- `println 10`と記載することはできないが、`Console println 10`と記載することはできる
- Scalaは伝統的な意味のオペレータは持っていないので、技術的にはオペレータオーバーロードは持っていない
- 代わりに、+,-,*,/ はメソッドの名前として使える
- これにより、Step1で示した`1+2`は、実際にはオブジェクト1の+メソッドが起動し、オブジェクト2がパラメータとして渡されている

